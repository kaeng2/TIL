import sys
input = sys.stdin.readline
from collections import defaultdict


'''
고려해야 할 부분 집합의 원소의 개수가 일정하게 유지되므로, 투 포인터 유형 중 슬라이딩 윈도우에 해당한다.
시작 포인터와 끝 포인터를 하나씩 올려가면서 각 부분 집합 내의 서로 다른 원소의 개수를 체크해 주는 것이 핵심이다. 

매 부분 집합마다 서로 다른 원소의 개수를 새로 세는 것은 비효율적이므로, 
초밥의 가짓수를 기록하는 별도의 변수 t를 만들고 원소가 빠지거나 추가될 때마다 t 값을 갱신해주었다.

원소가 빠지거나 추가될 때 초밥의 가짓수에도 변동이 생기는지 판별하기 위해서 원소의 종류 - 개수를 key - value로 하는 딕셔너리를 이용했다.
해당 종류의 value(개수) 값이 0이 되면 가짓수가 1 줄어들고, 해당 종류의 value(개수) 값이 0에서 1로 바뀔 때 가짓수가 1 늘어난다.
쿠폰 번호로 먹게되는 초밥은 딕셔너리에 미리 추가해 두었다.

딕셔너리의 value 값의 합은 항상 k+1이므로 각 value값이 모두 1 이하라면 서로 다른 원소의 개수가 k+1개가 된다.
'''

# 입력
N, d, k, c = map(int, input().split())      # 벨트 위의 접시의 수, 초밥의 가짓수, 연속해서 먹어야 하는 접시의 수, 쿠폰 번호
belt = [int(input()) for _ in range(N)]     # belt[i] = i번째 접시 위의 초밥의 종류

# 0번부터 k개의 접시 선택하기
s, e = 0, 0
ate = defaultdict(int)                                # ate[i] = 선택된 초밥 중 종류가 i인 초밥의 개수
ate[c] = 1
while e < k:
    ate[belt[e]] += 1
    e += 1

# 초기값 설정
t = len(ate)                                # 쿠폰 포함 하여 먹을 수 있는 초밥의 가짓수
ans = t

# 가능한 경우 탐색하기
while s < N-1 and ans < k+1:        # k개의 접시를 선택하는 모든 경우의 수 탐색. ans가 가능한 최대값을 달성하면 종료

    ate[belt[s]] -= 1                           # 시작점에 있던 접시는 뺀다.
    if not ate[belt[s]]:                        # 해당 초밥 종류가 이제 없다면
        t -= 1                                      # 가짓수가 1개 줄어든다.
    s += 1                                      # 시작점 갱신

    if not ate[belt[e % N]]:                    # 끝점에 있는 초밥이 새로운 종류라면
        t += 1                                      # 가짓수가 1개 늘어난다.
    ate[belt[e % N]] += 1                       # 끝점에 있는 접시 추가
    e += 1                                      # 끝점 갱신

    ans = max(ans, t)                           # ans 갱신

# 출력
print(ans)
