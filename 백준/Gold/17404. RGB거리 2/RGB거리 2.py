import sys
input = sys.stdin.readline

# 입력
N = int(input())                                                        # 집의 개수
cost = [list(map(int, input().split())) for _ in range(N)]              # cost[i] = i번째 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용

# dp 배열 채우기
'''
dp[0] = cost[0]
dp[i] = [
    첫번째 집을 빨간색으로 칠하고 i번째 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용
    첫번째 집을 초록색으로 칠하고 i번째 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용
    첫번째 집을 파란색으로 칠하고 i번째 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용
]

다만 두번째 집은 첫번째 집과 같은 색깔로 칠할 수 없으므로,
    dp[1][0][0] = 첫번째 집을 빨간색으로 칠하고 두번째 집을 빨간색으로 칠하는 비용
    dp[1][1][1] = 첫번째 집을 초록색으로 칠하고 두번째 집을 초록색으로 칠하는 비용
    dp[1][2][2] = 첫번째 집을 파란색으로 칠하고 두번째 집을 파란색으로 칠하는 비용
위의 세 요소는 가능한 최대값인 2000으로 설정했다.
'''

dp = [cost[0]] + [[[0, 0, 0] for _ in range(3)] for _ in range(N-1)]
dp[1] = [
    [2000, cost[0][0] + cost[1][1], cost[0][0] + cost[1][2]],
    [cost[0][1] + cost[1][0], 2000, cost[0][1] + cost[1][2]],
    [cost[0][2] + cost[1][0], cost[0][2] + cost[1][1], 2000]
]

for i in range(2, N):
    for j in range(3):
        for k in range(3):
            min_cost = min([dp[i-1][j][x] for x in range(3) if x != k])    # 이전 집과 같은 색으로 칠할 수 없음
            dp[i][j][k] = min_cost + cost[i][k]

# 최소 비용 출력
'''
모든 집을 칠하는 최소 비용은 
dp[N-1] = [
    첫번째 집을 빨간색으로 칠하고 마지막 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용
    첫번째 집을 초록색으로 칠하고 마지막 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용
    첫번째 집을 파란색으로 칠하고 마지막 집을 [빨간색, 초록색, 파란색] 으로 칠하는 비용
]
중 에서 첫번째 집과 마지막 집을 같은 색깔로 칠하는 경우를 제외한 경우 중의 최소값이 된다.
'''

print(min(dp[N-1][0][1], dp[N-1][0][2], dp[N-1][1][0], dp[N-1][1][2], dp[N-1][2][0], dp[N-1][2][1]))