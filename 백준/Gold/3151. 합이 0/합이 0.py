import sys
input = sys.stdin.readline


N = int(input())                                    # 학생 수
capa = sorted(list(map(int, input().split())))      # capa[i] = i번째 학생의 코딩 실력 (정렬 하여 저장)
ans = 0                                             # 코딩 실력의 합이 0이 되는 경우의 수

'''
첫번째 멤버를 고정해 놓고, 첫번째 멤버보다 코딩 실력이 뛰어난 학생들 중 두 명을 뽑아 팀을 이룬다.
해당 팀의 코딩 실력의 합과 0을 비교한 결과에 따라 시작 포인터나 끝 포인터를 이동시키며 탐색한다.

이 때 고려해야 할 케이스
    1. 첫번째 멤버의 코딩 실력이 양수인 경우
        나머지 멤버들의 코딩 실력도 양수이므로, 어떤 조합으로도 실력의 합이 0이 될 수 없다.
    2. 팀의 코딩 실력의 합이 정확이 0인 경우
        1. -4 2 2 2 2의 케이스에서처럼, 두번째 멤버와 세번째 멤버로 결정된 학생들의 코딩 실력이 동일한 경우
            두번째 멤버(s)와 세번째 멤버(e)를 포함하여 그들과 코딩 실력이 동일한 학생은 총 e-s+1 명이다.
            따라서 첫번째 멤버가 -4의 코딩 실력을 가질 때, 팀의 코딩 실력의 합이 0이 되는 경우의 수는
            (e-s+1) choose 2의 경우의 수와 같다.
        2. -4 1 1 1 1 1 2 3 3 3의 케이스에서처럼, 두번째 멤버와 세번째 멤버로 결정된 학생들의 코딩 실력이 다른 경우
            첫번째 멤버가 -4의 코딩 실력을 가질 때, 두번째 멤버와 세번째 멤버의 코딩 실력은 각각 1과 3이어야 한다.
            이 때 코딩 실력이 1인 학생은 5명, 코딩 실력이 3인 학생은 3명이므로, 합이 0이 되는 경우의 수는 5*3이다.
            따라서 정답 변수에 5*3만큼을 더해주고, 코딩 실력이 1과 3인 경우는 모두 고려했으므로
            코딩 실력이 처음으로 1이 아니게 되는 인덱스를 s로, 처음으로 3이 아니게 되는 인덱스를 e로 설정하여 탐색을 지속한다.
'''
for i in range(N-2):                        # 첫번째 멤버 i에 대해서

    if capa[i] > 0:                             # 첫번째 멤버의 코딩 실력이 양수인 경우.
        break

    s, e = i+1, N-1                             # i번 멤버보다 코딩 실력이 뛰어난 학생들 중 꼴등과 일등을 최초 팀으로 설정
    while s < e and capa[e] >= 0:               # s == e 가 되거나 제일 실력이 뛰어난 학생의 실력이 음수가 되면 종료
        team = capa[i] + capa[s] + capa[e]          # 코딩 실력의 합
        
        if team < 0:                                # 0보다 작은 경우
            s += 1                                      # 제일 못하는 애 방출
        elif team > 0:                              # 0보다 큰 경우
            e -= 1                                      # 제일 잘하는 애 방출
        
        else:                                       # 정확히 0인 경우
            if capa[s] == capa[e]:                      # s부터 e까지 코딩 실력이 모두 동일한 경우
                ans += (e-s+1) * (e-s) // 2                 # ans += (e-s+1) choose 2
                break                                       # 다음 i에 대해서 탐색
            else:                                       # s번과 e번의 코딩 실력이 다른 경우
                a, m1 = capa[s], 0                          # s번의 코딩 실력, 코딩 실력이 a인 학생 수
                while capa[s] == a:                         # 코딩 실력이 a와 달라질 때까지
                    s += 1                                      # s를 높인다
                    m1 += 1                                     # 코딩 실력이 a인 학생 수 1 추가
                b, m2 = capa[e], 0                          # e번의 코딩 실력, 코딩 실력이 b인 학생 수
                while capa[e] == b:                         # 코딩 실력이 b와 달라질 때까지
                    e -= 1                                      # e를 줄인다
                    m2 += 1                                     # 코딩 실력이 b인 학생 수 1 추가
                ans += m1 * m2                              # ans += (코딩 실력이 a인 학생 수) * (코딩 실력이 b인 학생 수)
print(ans)